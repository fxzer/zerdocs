import{_ as e,e as o,ab as t,b as l}from"./chunks/framework.bab49m2N.js";const m=JSON.parse('{"title":"浏览器网页请求过程","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/Brower/浏览器网页请求过程.md","filePath":"Interview/Brower/浏览器网页请求过程.md"}'),i={name:"Interview/Brower/浏览器网页请求过程.md"};function r(s,a,p,c,h,n){return l(),o("div",null,a[0]||(a[0]=[t('<h1 id="浏览器网页请求过程" tabindex="-1">浏览器网页请求过程 <a class="header-anchor" href="#浏览器网页请求过程" aria-label="Permalink to &quot;浏览器网页请求过程&quot;">​</a></h1><ol><li>网络：请求资源</li><li>渲染：处理渲染</li></ol><div class="tip custom-block"><p class="custom-block-title">完整的 HTTP 请求过程</p><p>域名解析 ==&gt; 与服务器建立连接 ==&gt; 发起 HTTP 请求 ==&gt; 服务器响应 HTTP 请求，浏览器得到 html 代码 ==&gt; 浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片） ==&gt; 浏览器对页面进行渲染呈现给用户</p></div><h2 id="一、域名解析" tabindex="-1">一、域名解析 <a class="header-anchor" href="#一、域名解析" aria-label="Permalink to &quot;一、域名解析&quot;">​</a></h2><ol><li>Chrome 浏览器 会首先搜索浏览器自身的 DNS 缓存，有且没有过期则解析到此结束。</li><li>如果浏览器自身的缓存里面没有找到对应的条目，会搜索操作系统自身的 DNS 缓存，有且没有过期则停止搜索解析到此结束</li></ol><blockquote><p>Windows 系统：<code>ipconfig/displaydns</code> 命令查看</p></blockquote><ol start="3"><li>如果在 Windows 系统的 DNS 缓存也没有找到，则读取 hosts 文件</li></ol><blockquote><p>hosts 位于 <code>‪C:\\Windows\\System32\\drivers\\etc\\hosts</code></p></blockquote><ol start="4"><li><p>hosts 文件中也没有找到对应的条目，浏览器就会发起一个 DNS 的系统调用，就会向本地配置的首选 DNS 服务器发起域名解析请求</p><p>并返回给 Windows 系统内核，内核又把结果返回给浏览器。（这是递归的请求，也就是运营商的 DNS 服务器必须得提供并返回该域名的 IP 地址）</p></li><li><p>经过以上的 4 个步骤，还没有解析成功</p></li></ol><blockquote><p>注：一般会进行以下几步</p><p>操作系统就会查找 NetBIOS name Cache == &gt; WINS 服务器 ==&gt; 客户端就要进行广播查找 ==&gt; 客户端就读取 LMHOSTS 文件</p></blockquote><p>如果还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要其中有一步可以解析成功，那就可以成功和目标计算机进行通信。</p><h2 id="二、与服务器建立连接" tabindex="-1">二、与服务器建立连接 <a class="header-anchor" href="#二、与服务器建立连接" aria-label="Permalink to &quot;二、与服务器建立连接&quot;">​</a></h2><ol><li>TCP 连接的建立</li></ol><p>客户端的请求到达服务器，首先就是三次握手建立 TCP 连接</p><blockquote><p>三次握手的目的：试探一下对方是否遵循 TCP/IP 协议，为了在不可靠的信道上建立起可靠的连接</p></blockquote><blockquote><p><strong>为什么要进行第三次握手</strong>：为了防止服务器端开启一些无用的连接，增加服务器开销；</p><p>以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p></blockquote><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" alt="img" data-zoomable=""></p><h2 id="三、发起-http-请求" tabindex="-1">三、发起 HTTP 请求 <a class="header-anchor" href="#三、发起-http-请求" aria-label="Permalink to &quot;三、发起 HTTP 请求&quot;">​</a></h2><p>http 协议：计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于 TCP/IP 协议传输数据。</p><h3 id="请求报文结构" tabindex="-1">请求报文结构 <a class="header-anchor" href="#请求报文结构" aria-label="Permalink to &quot;请求报文结构&quot;">​</a></h3><p>请求报文包括四个部分：请求行，请求头，空行，请求体。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" alt="img" data-zoomable=""></p><h2 id="四、服务器端响应-http-请求-浏览器得到-html-代码" tabindex="-1">四、服务器端响应 HTTP 请求，浏览器得到 HTML 代码 <a class="header-anchor" href="#四、服务器端响应-http-请求-浏览器得到-html-代码" aria-label="Permalink to &quot;四、服务器端响应 HTTP 请求，浏览器得到 HTML 代码&quot;">​</a></h2><p>HTTP 的响应报文也由四部分组成：响应行、响应头、空行、响应体</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" alt="img" data-zoomable=""></p><p><a href="https://blog.csdn.net/lyn_00/article/details/84953763" target="_blank" rel="noreferrer">报文结构参考</a></p><h2 id="五、浏览器渲染过程" tabindex="-1">五、浏览器渲染过程 <a class="header-anchor" href="#五、浏览器渲染过程" aria-label="Permalink to &quot;五、浏览器渲染过程&quot;">​</a></h2><p><img src="https://zerdocs.oss-cn-shanghai.aliyuncs.com/febasis/2023-03-05-22-05-19.png" alt="2023-03-05-22-05-19" data-zoomable=""></p><ol><li>解析 html 结构，形成 Dom 树</li><li>解析 CSS，生成 cssom</li><li>将 CSSOM 和 DOM 合并形成 render 树</li><li>计算 layout 布局</li><li>将布局渲染到屏幕上</li></ol><p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p><h3 id="一、解析-html" tabindex="-1">一、解析 HTML <a class="header-anchor" href="#一、解析-html" aria-label="Permalink to &quot;一、解析 HTML&quot;">​</a></h3><p>解析过程中遇到 CSS 解析 CSS，遇到 JS执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和外部的JS 文件。</p><p>如果主线程解析到 link 位置，此时外部的CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 css 的工作是在预解析线程中进行的。这就是csS 不会阻塞 HTML 解析的根本原因。</p><p>如果主线程解析到 script 位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 Js 代码的执行过程可能会修改当前的DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阳塞 HTML 解析的根本原因。</p><p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。 <img src="https://zerdocs.oss-cn-shanghai.aliyuncs.com/febasis/2023-03-05-22-07-54.png" alt="2023-03-05-22-07-54" data-zoomable=""><img src="https://zerdocs.oss-cn-shanghai.aliyuncs.com/febasis/2023-03-05-22-29-15.png" alt="2023-03-05-22-29-15" data-zoomable=""></p><blockquote><p>解析成对象，提供 JS 可操作的能力</p></blockquote><h3 id="二、解析-css" tabindex="-1">二、解析 CSS <a class="header-anchor" href="#二、解析-css" aria-label="Permalink to &quot;二、解析 CSS&quot;">​</a></h3><p><img src="https://zerdocs.oss-cn-shanghai.aliyuncs.com/febasis/2023-03-05-22-10-48.png" alt="2023-03-05-22-10-48" data-zoomable=""></p><blockquote><p><code>document.styleSheets、document.styleSheets[0].addRule(&#39;div&#39;:&#39;border :2px solid red&#39;)</code> 可查看、操作浏览器样式表</p></blockquote><h3 id="三、样式计算" tabindex="-1">三、样式计算 <a class="header-anchor" href="#三、样式计算" aria-label="Permalink to &quot;三、样式计算&quot;">​</a></h3><p>主线程会遍历得到的DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 <code>Computed Style</code>。</p><p>在这一过程中，很多预设值会变成绝对值，比如 red 会变成 rgb；相对单位会变成绝对单位，比如 em 会变成 px</p><p>这一步完成后，会得到一棵带有样式的DOM 树</p><p><img src="https://zerdocs.oss-cn-shanghai.aliyuncs.com/febasis/2023-03-05-22-31-23.png" alt="2023-03-05-22-31-23" data-zoomable=""></p><h3 id="四、布局layout" tabindex="-1">四、布局Layout <a class="header-anchor" href="#四、布局layout" aria-label="Permalink to &quot;四、布局Layout&quot;">​</a></h3><p>DOM树和 Layout 不一定是一一对应的，比如<code>head</code>默认样式<code>display:none</code>,<code>::before</code>在 Layout 树阶段，布局完成后形成布局树。</p><p><img src="https://zerdocs.oss-cn-shanghai.aliyuncs.com/febasis/2023-03-05-22-38-44.png" alt="2023-03-05-22-38-44" data-zoomable=""></p><h3 id="五、分层layer" tabindex="-1">五、分层Layer <a class="header-anchor" href="#五、分层layer" aria-label="Permalink to &quot;五、分层Layer&quot;">​</a></h3><p>主线程使用复杂的策略对布局树进行分层。</p><h3 id="六、绘制paint" tabindex="-1">六、绘制Paint <a class="header-anchor" href="#六、绘制paint" aria-label="Permalink to &quot;六、绘制Paint&quot;">​</a></h3><p>为每个层生成绘制指令</p><h3 id="七、分块tiling" tabindex="-1">七、分块Tiling <a class="header-anchor" href="#七、分块tiling" aria-label="Permalink to &quot;七、分块Tiling&quot;">​</a></h3><p>分块工作交给多个线程同时进行</p><h3 id="八、光栅化raster" tabindex="-1">八、光栅化Raster <a class="header-anchor" href="#八、光栅化raster" aria-label="Permalink to &quot;八、光栅化Raster&quot;">​</a></h3><p>合成线程将信息交给 GPU 进程，将每个快变成位图，优先处理靠近视口的块，此过程会用到 GPU 加速，提升运算速率。</p><h3 id="九、画draw" tabindex="-1">九、画Draw <a class="header-anchor" href="#九、画draw" aria-label="Permalink to &quot;九、画Draw&quot;">​</a></h3><p>合成线程计算出每个位图在屏幕上的位置，交给 GPU 进行呈现。变形（旋转，缩放，倾斜）等发生在合成线程，与渲染主线程无关，这是 <code>transform</code> 效率高的本质原因。</p><p><img src="https://zerdocs.oss-cn-shanghai.aliyuncs.com/febasis/2023-03-06-21-54-14.png" alt="2023-03-06-21-54-14" data-zoomable=""></p><h3 id="回流reflow" tabindex="-1">回流reflow <a class="header-anchor" href="#回流reflow" aria-label="Permalink to &quot;回流reflow&quot;">​</a></h3><p><img src="https://zerdocs.oss-cn-shanghai.aliyuncs.com/febasis/2023-03-06-21-56-10.png" alt="2023-03-06-21-56-10" data-zoomable=""></p><p>reflow 的本质就是重新计算 layout 树。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 ref1ow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息浏览器在反复权衡下，最终决定获取属性立即 ref1ow。</p><div class="tip custom-block"><p class="custom-block-title">引起回流属性和方法：任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p><ol><li>页面首次渲染</li><li>添加或者删除可见的DOM元素</li><li>元素尺寸或位置发生改变</li><li>元素字体大小变化</li><li>浏览器窗口大小发生改变</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法</li></ol></div><h3 id="重绘repaint" tabindex="-1">重绘repaint <a class="header-anchor" href="#重绘repaint" aria-label="Permalink to &quot;重绘repaint&quot;">​</a></h3><p>repaint 的本质就是重新根据分层信息计算了绘制指令。 当改动了可见样式后，就需要重新计算，会引发 repaint。 由于元素的布局信息也属于可见样式，所以reflow 一定会引起 repaint。 需要更新属性，只是影响元素的外观、风格，不影响布局。(不影响布局的属性，如：color、background-color、visibility 等) <img src="https://zerdocs.oss-cn-shanghai.aliyuncs.com/febasis/2023-03-06-22-20-02.png" alt="2023-03-06-22-20-02" data-zoomable=""></p><details class="details custom-block"><summary>为什么 transform 的效率高?</summary><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」 阶段由于 draw 阶段在合成线程中；</p><p>所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌．也不会影响 transform 的变化。</p></details><p><a href="https://blog.51cto.com/u_15499114/4971560" target="_blank" rel="noreferrer">参考链接</a></p><h2 id="六、浏览器对页面进行渲染呈现给用户-关闭连接" tabindex="-1">六、浏览器对页面进行渲染呈现给用户，关闭连接 <a class="header-anchor" href="#六、浏览器对页面进行渲染呈现给用户-关闭连接" aria-label="Permalink to &quot;六、浏览器对页面进行渲染呈现给用户，关闭连接&quot;">​</a></h2><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" alt="img" data-zoomable=""></p><p>问题一：</p><p>为什么连接的时候是三次握手，关闭的时候却是四次握手？</p><blockquote><p>为了保障数据发送完再断开连接</p></blockquote><p>问题二：</p><p>为什么要等待一段时间在关闭连接？</p><blockquote><p>因为客户端发送完 ack 包后中途可能丢失，此时服务端未收到 ack 包会重发 fin 包，客户端在发送 ack 包刷新等待时间，</p><p>确保服务端关闭再 关闭客户端</p></blockquote><p><a href="https://www.bilibili.com/video/BV1kV411j7hA?from=search&amp;seid=11094337157520488587" target="_blank" rel="noreferrer">参考视频 1</a></p><p><a href="https://www.bilibili.com/video/BV1BV411a72M?from=search&amp;seid=4937986881420888725" target="_blank" rel="noreferrer">参考视频 2</a></p>',80)]))}const b=e(i,[["render",r]]);export{m as __pageData,b as default};
